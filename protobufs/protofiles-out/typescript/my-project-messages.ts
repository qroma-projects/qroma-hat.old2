// @generated by protobuf-ts 2.9.3 with parameter use_proto_field_name,generate_dependencies
// @generated from protobuf file "my-project-messages.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message UpdateConfiguration
 */
export interface UpdateConfiguration {
    /**
     * @generated from protobuf field: UpdateType updateType = 1;
     */
    updateType: UpdateType;
    /**
     * @generated from protobuf field: uint32 updateIntervalInMs = 2;
     */
    updateIntervalInMs: number;
}
/**
 * @generated from protobuf message SetUpdateConfiguration
 */
export interface SetUpdateConfiguration {
    /**
     * @generated from protobuf field: UpdateConfiguration updateConfiguration = 1;
     */
    updateConfiguration?: UpdateConfiguration;
    /**
     * @generated from protobuf field: bool saveConfiguration = 2;
     */
    saveConfiguration: boolean;
}
/**
 * @generated from protobuf message HatConfiguration
 */
export interface HatConfiguration {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
    /**
     * @generated from protobuf field: bool rotateImage = 2;
     */
    rotateImage: boolean;
}
/**
 * @generated from protobuf message SetHatRotateImageCommand
 */
export interface SetHatRotateImageCommand {
    /**
     * @generated from protobuf field: bool rotateImage = 1;
     */
    rotateImage: boolean;
}
/**
 * @generated from protobuf message SetHatImageCommand
 */
export interface SetHatImageCommand {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
}
/**
 * @generated from protobuf message GetDgsrImageValidationResultCommand
 */
export interface GetDgsrImageValidationResultCommand {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
}
/**
 * @generated from protobuf message MyProjectCommand
 */
export interface MyProjectCommand {
    /**
     * @generated from protobuf oneof: command
     */
    command: {
        oneofKind: "noArgCommand";
        /**
         * @generated from protobuf field: NoArgCommands noArgCommand = 1;
         */
        noArgCommand: NoArgCommands;
    } | {
        oneofKind: "setHatImage";
        /**
         * @generated from protobuf field: SetHatImageCommand setHatImage = 2;
         */
        setHatImage: SetHatImageCommand;
    } | {
        oneofKind: "setHatRotateImage";
        /**
         * @generated from protobuf field: SetHatRotateImageCommand setHatRotateImage = 3;
         */
        setHatRotateImage: SetHatRotateImageCommand;
    } | {
        oneofKind: "getDgsrImageValidationResult";
        /**
         * @generated from protobuf field: GetDgsrImageValidationResultCommand getDgsrImageValidationResult = 4;
         */
        getDgsrImageValidationResult: GetDgsrImageValidationResultCommand;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message InvalidCommandResponse
 */
export interface InvalidCommandResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message ConfigurationResponse
 */
export interface ConfigurationResponse {
    /**
     * @generated from protobuf field: UpdateConfiguration updateConfiguration = 1;
     */
    updateConfiguration?: UpdateConfiguration;
    /**
     * @generated from protobuf field: HatConfiguration hatConfiguration = 2;
     */
    hatConfiguration?: HatConfiguration;
}
/**
 * @generated from protobuf message FirmwareDetailsResponse
 */
export interface FirmwareDetailsResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: string buildTime = 2;
     */
    buildTime: string;
}
/**
 * @generated from protobuf message UpdateResponse
 */
export interface UpdateResponse {
    /**
     * @generated from protobuf field: uint32 boardUptimeInMs = 1;
     */
    boardUptimeInMs: number;
}
/**
 * @generated from protobuf message SetHatImageResponse
 */
export interface SetHatImageResponse {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
    /**
     * @generated from protobuf field: bool success = 2;
     */
    success: boolean;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf message GetDgsrImageValidationResultResponse
 */
export interface GetDgsrImageValidationResultResponse {
    /**
     * @generated from protobuf field: string imagePath = 1;
     */
    imagePath: string;
    /**
     * @generated from protobuf field: bool isValid = 2;
     */
    isValid: boolean;
    /**
     * @generated from protobuf field: string message = 3;
     */
    message: string;
}
/**
 * @generated from protobuf message MyProjectResponse
 */
export interface MyProjectResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "invalidCommandResponse";
        /**
         * @generated from protobuf field: InvalidCommandResponse invalidCommandResponse = 1;
         */
        invalidCommandResponse: InvalidCommandResponse;
    } | {
        oneofKind: "firmwareDetailsResponse";
        /**
         * @generated from protobuf field: FirmwareDetailsResponse firmwareDetailsResponse = 2;
         */
        firmwareDetailsResponse: FirmwareDetailsResponse;
    } | {
        oneofKind: "updateResponse";
        /**
         * @generated from protobuf field: UpdateResponse updateResponse = 3;
         */
        updateResponse: UpdateResponse;
    } | {
        oneofKind: "configurationResponse";
        /**
         * @generated from protobuf field: ConfigurationResponse configurationResponse = 4;
         */
        configurationResponse: ConfigurationResponse;
    } | {
        oneofKind: "setHatImageResponse";
        /**
         * @generated from protobuf field: SetHatImageResponse setHatImageResponse = 5;
         */
        setHatImageResponse: SetHatImageResponse;
    } | {
        oneofKind: "getDgsrImageValidationResultResponse";
        /**
         * @generated from protobuf field: GetDgsrImageValidationResultResponse getDgsrImageValidationResultResponse = 6;
         */
        getDgsrImageValidationResultResponse: GetDgsrImageValidationResultResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum UpdateType
 */
export enum UpdateType {
    /**
     * @generated from protobuf enum value: UpdateType_NotSet = 0;
     */
    UpdateType_NotSet = 0,
    /**
     * @generated from protobuf enum value: UpdateType_None = 1;
     */
    UpdateType_None = 1,
    /**
     * @generated from protobuf enum value: UpdateType_Interval = 2;
     */
    UpdateType_Interval = 2
}
/**
 * @generated from protobuf enum NoArgCommands
 */
export enum NoArgCommands {
    /**
     * @generated from protobuf enum value: Nac_NotSet = 0;
     */
    Nac_NotSet = 0,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToWhite = 1;
     */
    Nac_ClearScreenToWhite = 1,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToBlack = 2;
     */
    Nac_ClearScreenToBlack = 2,
    /**
     * @generated from protobuf enum value: Nac_GetConfiguration = 3;
     */
    Nac_GetConfiguration = 3,
    /**
     * @generated from protobuf enum value: Nac_GetFirmwareDetails = 4;
     */
    Nac_GetFirmwareDetails = 4,
    /**
     * @generated from protobuf enum value: Nac_RestartDevice = 5;
     */
    Nac_RestartDevice = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class UpdateConfiguration$Type extends MessageType<UpdateConfiguration> {
    constructor() {
        super("UpdateConfiguration", [
            { no: 1, name: "updateType", kind: "enum", T: () => ["UpdateType", UpdateType] },
            { no: 2, name: "updateIntervalInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateConfiguration>): UpdateConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateType = 0;
        message.updateIntervalInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateConfiguration): UpdateConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateType updateType */ 1:
                    message.updateType = reader.int32();
                    break;
                case /* uint32 updateIntervalInMs */ 2:
                    message.updateIntervalInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateType updateType = 1; */
        if (message.updateType !== 0)
            writer.tag(1, WireType.Varint).int32(message.updateType);
        /* uint32 updateIntervalInMs = 2; */
        if (message.updateIntervalInMs !== 0)
            writer.tag(2, WireType.Varint).uint32(message.updateIntervalInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateConfiguration
 */
export const UpdateConfiguration = new UpdateConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetUpdateConfiguration$Type extends MessageType<SetUpdateConfiguration> {
    constructor() {
        super("SetUpdateConfiguration", [
            { no: 1, name: "updateConfiguration", kind: "message", T: () => UpdateConfiguration },
            { no: 2, name: "saveConfiguration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetUpdateConfiguration>): SetUpdateConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.saveConfiguration = false;
        if (value !== undefined)
            reflectionMergePartial<SetUpdateConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetUpdateConfiguration): SetUpdateConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateConfiguration updateConfiguration */ 1:
                    message.updateConfiguration = UpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.updateConfiguration);
                    break;
                case /* bool saveConfiguration */ 2:
                    message.saveConfiguration = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetUpdateConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateConfiguration updateConfiguration = 1; */
        if (message.updateConfiguration)
            UpdateConfiguration.internalBinaryWrite(message.updateConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool saveConfiguration = 2; */
        if (message.saveConfiguration !== false)
            writer.tag(2, WireType.Varint).bool(message.saveConfiguration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetUpdateConfiguration
 */
export const SetUpdateConfiguration = new SetUpdateConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HatConfiguration$Type extends MessageType<HatConfiguration> {
    constructor() {
        super("HatConfiguration", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "rotateImage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HatConfiguration>): HatConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        message.rotateImage = false;
        if (value !== undefined)
            reflectionMergePartial<HatConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HatConfiguration): HatConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                case /* bool rotateImage */ 2:
                    message.rotateImage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HatConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        /* bool rotateImage = 2; */
        if (message.rotateImage !== false)
            writer.tag(2, WireType.Varint).bool(message.rotateImage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HatConfiguration
 */
export const HatConfiguration = new HatConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetHatRotateImageCommand$Type extends MessageType<SetHatRotateImageCommand> {
    constructor() {
        super("SetHatRotateImageCommand", [
            { no: 1, name: "rotateImage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetHatRotateImageCommand>): SetHatRotateImageCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rotateImage = false;
        if (value !== undefined)
            reflectionMergePartial<SetHatRotateImageCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHatRotateImageCommand): SetHatRotateImageCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool rotateImage */ 1:
                    message.rotateImage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHatRotateImageCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool rotateImage = 1; */
        if (message.rotateImage !== false)
            writer.tag(1, WireType.Varint).bool(message.rotateImage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetHatRotateImageCommand
 */
export const SetHatRotateImageCommand = new SetHatRotateImageCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetHatImageCommand$Type extends MessageType<SetHatImageCommand> {
    constructor() {
        super("SetHatImageCommand", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetHatImageCommand>): SetHatImageCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        if (value !== undefined)
            reflectionMergePartial<SetHatImageCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHatImageCommand): SetHatImageCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHatImageCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetHatImageCommand
 */
export const SetHatImageCommand = new SetHatImageCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDgsrImageValidationResultCommand$Type extends MessageType<GetDgsrImageValidationResultCommand> {
    constructor() {
        super("GetDgsrImageValidationResultCommand", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDgsrImageValidationResultCommand>): GetDgsrImageValidationResultCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        if (value !== undefined)
            reflectionMergePartial<GetDgsrImageValidationResultCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDgsrImageValidationResultCommand): GetDgsrImageValidationResultCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDgsrImageValidationResultCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDgsrImageValidationResultCommand
 */
export const GetDgsrImageValidationResultCommand = new GetDgsrImageValidationResultCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectCommand$Type extends MessageType<MyProjectCommand> {
    constructor() {
        super("MyProjectCommand", [
            { no: 1, name: "noArgCommand", kind: "enum", oneof: "command", T: () => ["NoArgCommands", NoArgCommands] },
            { no: 2, name: "setHatImage", kind: "message", oneof: "command", T: () => SetHatImageCommand },
            { no: 3, name: "setHatRotateImage", kind: "message", oneof: "command", T: () => SetHatRotateImageCommand },
            { no: 4, name: "getDgsrImageValidationResult", kind: "message", oneof: "command", T: () => GetDgsrImageValidationResultCommand }
        ]);
    }
    create(value?: PartialMessage<MyProjectCommand>): MyProjectCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectCommand): MyProjectCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NoArgCommands noArgCommand */ 1:
                    message.command = {
                        oneofKind: "noArgCommand",
                        noArgCommand: reader.int32()
                    };
                    break;
                case /* SetHatImageCommand setHatImage */ 2:
                    message.command = {
                        oneofKind: "setHatImage",
                        setHatImage: SetHatImageCommand.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setHatImage)
                    };
                    break;
                case /* SetHatRotateImageCommand setHatRotateImage */ 3:
                    message.command = {
                        oneofKind: "setHatRotateImage",
                        setHatRotateImage: SetHatRotateImageCommand.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setHatRotateImage)
                    };
                    break;
                case /* GetDgsrImageValidationResultCommand getDgsrImageValidationResult */ 4:
                    message.command = {
                        oneofKind: "getDgsrImageValidationResult",
                        getDgsrImageValidationResult: GetDgsrImageValidationResultCommand.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).getDgsrImageValidationResult)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NoArgCommands noArgCommand = 1; */
        if (message.command.oneofKind === "noArgCommand")
            writer.tag(1, WireType.Varint).int32(message.command.noArgCommand);
        /* SetHatImageCommand setHatImage = 2; */
        if (message.command.oneofKind === "setHatImage")
            SetHatImageCommand.internalBinaryWrite(message.command.setHatImage, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* SetHatRotateImageCommand setHatRotateImage = 3; */
        if (message.command.oneofKind === "setHatRotateImage")
            SetHatRotateImageCommand.internalBinaryWrite(message.command.setHatRotateImage, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* GetDgsrImageValidationResultCommand getDgsrImageValidationResult = 4; */
        if (message.command.oneofKind === "getDgsrImageValidationResult")
            GetDgsrImageValidationResultCommand.internalBinaryWrite(message.command.getDgsrImageValidationResult, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectCommand
 */
export const MyProjectCommand = new MyProjectCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvalidCommandResponse$Type extends MessageType<InvalidCommandResponse> {
    constructor() {
        super("InvalidCommandResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InvalidCommandResponse>): InvalidCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<InvalidCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvalidCommandResponse): InvalidCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvalidCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InvalidCommandResponse
 */
export const InvalidCommandResponse = new InvalidCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class ConfigurationResponse$Type extends MessageType<ConfigurationResponse> {
    constructor() {
        super("ConfigurationResponse", [
            { no: 1, name: "updateConfiguration", kind: "message", T: () => UpdateConfiguration },
            { no: 2, name: "hatConfiguration", kind: "message", T: () => HatConfiguration }
        ]);
    }
    create(value?: PartialMessage<ConfigurationResponse>): ConfigurationResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        if (value !== undefined)
            reflectionMergePartial<ConfigurationResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: ConfigurationResponse): ConfigurationResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateConfiguration updateConfiguration */ 1:
                    message.updateConfiguration = UpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.updateConfiguration);
                    break;
                case /* HatConfiguration hatConfiguration */ 2:
                    message.hatConfiguration = HatConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.hatConfiguration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: ConfigurationResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateConfiguration updateConfiguration = 1; */
        if (message.updateConfiguration)
            UpdateConfiguration.internalBinaryWrite(message.updateConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* HatConfiguration hatConfiguration = 2; */
        if (message.hatConfiguration)
            HatConfiguration.internalBinaryWrite(message.hatConfiguration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message ConfigurationResponse
 */
export const ConfigurationResponse = new ConfigurationResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirmwareDetailsResponse$Type extends MessageType<FirmwareDetailsResponse> {
    constructor() {
        super("FirmwareDetailsResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "buildTime", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FirmwareDetailsResponse>): FirmwareDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.buildTime = "";
        if (value !== undefined)
            reflectionMergePartial<FirmwareDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FirmwareDetailsResponse): FirmwareDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string buildTime */ 2:
                    message.buildTime = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FirmwareDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string buildTime = 2; */
        if (message.buildTime !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.buildTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FirmwareDetailsResponse
 */
export const FirmwareDetailsResponse = new FirmwareDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
    constructor() {
        super("UpdateResponse", [
            { no: 1, name: "boardUptimeInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boardUptimeInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateResponse): UpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 boardUptimeInMs */ 1:
                    message.boardUptimeInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 boardUptimeInMs = 1; */
        if (message.boardUptimeInMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.boardUptimeInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetHatImageResponse$Type extends MessageType<SetHatImageResponse> {
    constructor() {
        super("SetHatImageResponse", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "success", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<SetHatImageResponse>): SetHatImageResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        message.success = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<SetHatImageResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHatImageResponse): SetHatImageResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                case /* bool success */ 2:
                    message.success = reader.bool();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHatImageResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        /* bool success = 2; */
        if (message.success !== false)
            writer.tag(2, WireType.Varint).bool(message.success);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetHatImageResponse
 */
export const SetHatImageResponse = new SetHatImageResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class GetDgsrImageValidationResultResponse$Type extends MessageType<GetDgsrImageValidationResultResponse> {
    constructor() {
        super("GetDgsrImageValidationResultResponse", [
            { no: 1, name: "imagePath", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "isValid", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 3, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<GetDgsrImageValidationResultResponse>): GetDgsrImageValidationResultResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.imagePath = "";
        message.isValid = false;
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<GetDgsrImageValidationResultResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: GetDgsrImageValidationResultResponse): GetDgsrImageValidationResultResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string imagePath */ 1:
                    message.imagePath = reader.string();
                    break;
                case /* bool isValid */ 2:
                    message.isValid = reader.bool();
                    break;
                case /* string message */ 3:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: GetDgsrImageValidationResultResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string imagePath = 1; */
        if (message.imagePath !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.imagePath);
        /* bool isValid = 2; */
        if (message.isValid !== false)
            writer.tag(2, WireType.Varint).bool(message.isValid);
        /* string message = 3; */
        if (message.message !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message GetDgsrImageValidationResultResponse
 */
export const GetDgsrImageValidationResultResponse = new GetDgsrImageValidationResultResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectResponse$Type extends MessageType<MyProjectResponse> {
    constructor() {
        super("MyProjectResponse", [
            { no: 1, name: "invalidCommandResponse", kind: "message", oneof: "response", T: () => InvalidCommandResponse },
            { no: 2, name: "firmwareDetailsResponse", kind: "message", oneof: "response", T: () => FirmwareDetailsResponse },
            { no: 3, name: "updateResponse", kind: "message", oneof: "response", T: () => UpdateResponse },
            { no: 4, name: "configurationResponse", kind: "message", oneof: "response", T: () => ConfigurationResponse },
            { no: 5, name: "setHatImageResponse", kind: "message", oneof: "response", T: () => SetHatImageResponse },
            { no: 6, name: "getDgsrImageValidationResultResponse", kind: "message", oneof: "response", T: () => GetDgsrImageValidationResultResponse }
        ]);
    }
    create(value?: PartialMessage<MyProjectResponse>): MyProjectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectResponse): MyProjectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* InvalidCommandResponse invalidCommandResponse */ 1:
                    message.response = {
                        oneofKind: "invalidCommandResponse",
                        invalidCommandResponse: InvalidCommandResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).invalidCommandResponse)
                    };
                    break;
                case /* FirmwareDetailsResponse firmwareDetailsResponse */ 2:
                    message.response = {
                        oneofKind: "firmwareDetailsResponse",
                        firmwareDetailsResponse: FirmwareDetailsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).firmwareDetailsResponse)
                    };
                    break;
                case /* UpdateResponse updateResponse */ 3:
                    message.response = {
                        oneofKind: "updateResponse",
                        updateResponse: UpdateResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).updateResponse)
                    };
                    break;
                case /* ConfigurationResponse configurationResponse */ 4:
                    message.response = {
                        oneofKind: "configurationResponse",
                        configurationResponse: ConfigurationResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).configurationResponse)
                    };
                    break;
                case /* SetHatImageResponse setHatImageResponse */ 5:
                    message.response = {
                        oneofKind: "setHatImageResponse",
                        setHatImageResponse: SetHatImageResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).setHatImageResponse)
                    };
                    break;
                case /* GetDgsrImageValidationResultResponse getDgsrImageValidationResultResponse */ 6:
                    message.response = {
                        oneofKind: "getDgsrImageValidationResultResponse",
                        getDgsrImageValidationResultResponse: GetDgsrImageValidationResultResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).getDgsrImageValidationResultResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* InvalidCommandResponse invalidCommandResponse = 1; */
        if (message.response.oneofKind === "invalidCommandResponse")
            InvalidCommandResponse.internalBinaryWrite(message.response.invalidCommandResponse, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* FirmwareDetailsResponse firmwareDetailsResponse = 2; */
        if (message.response.oneofKind === "firmwareDetailsResponse")
            FirmwareDetailsResponse.internalBinaryWrite(message.response.firmwareDetailsResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* UpdateResponse updateResponse = 3; */
        if (message.response.oneofKind === "updateResponse")
            UpdateResponse.internalBinaryWrite(message.response.updateResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* ConfigurationResponse configurationResponse = 4; */
        if (message.response.oneofKind === "configurationResponse")
            ConfigurationResponse.internalBinaryWrite(message.response.configurationResponse, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        /* SetHatImageResponse setHatImageResponse = 5; */
        if (message.response.oneofKind === "setHatImageResponse")
            SetHatImageResponse.internalBinaryWrite(message.response.setHatImageResponse, writer.tag(5, WireType.LengthDelimited).fork(), options).join();
        /* GetDgsrImageValidationResultResponse getDgsrImageValidationResultResponse = 6; */
        if (message.response.oneofKind === "getDgsrImageValidationResultResponse")
            GetDgsrImageValidationResultResponse.internalBinaryWrite(message.response.getDgsrImageValidationResultResponse, writer.tag(6, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectResponse
 */
export const MyProjectResponse = new MyProjectResponse$Type();
