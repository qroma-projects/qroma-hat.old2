// @generated by protobuf-ts 2.9.3 with parameter use_proto_field_name,generate_dependencies
// @generated from protobuf file "my-project-messages.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message UpdateConfiguration
 */
export interface UpdateConfiguration {
    /**
     * @generated from protobuf field: UpdateType updateType = 1;
     */
    updateType: UpdateType;
    /**
     * @generated from protobuf field: uint32 updateIntervalInMs = 2;
     */
    updateIntervalInMs: number;
}
/**
 * @generated from protobuf message SetUpdateConfiguration
 */
export interface SetUpdateConfiguration {
    /**
     * @generated from protobuf field: UpdateConfiguration updateConfiguration = 1;
     */
    updateConfiguration?: UpdateConfiguration;
    /**
     * @generated from protobuf field: bool saveConfiguration = 2;
     */
    saveConfiguration: boolean;
}
/**
 * @generated from protobuf message MyProjectCommand
 */
export interface MyProjectCommand {
    /**
     * @generated from protobuf oneof: command
     */
    command: {
        oneofKind: "noArgCommand";
        /**
         * @generated from protobuf field: NoArgCommands noArgCommand = 1;
         */
        noArgCommand: NoArgCommands;
    } | {
        oneofKind: "showFileImage";
        /**
         * @generated from protobuf field: string showFileImage = 2;
         */
        showFileImage: string;
    } | {
        oneofKind: "setUpdateConfiguration";
        /**
         * @generated from protobuf field: SetUpdateConfiguration setUpdateConfiguration = 3;
         */
        setUpdateConfiguration: SetUpdateConfiguration;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message InvalidCommandResponse
 */
export interface InvalidCommandResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message HatDetailsResponse
 */
export interface HatDetailsResponse {
    /**
     * @generated from protobuf field: bool isScreenClear = 1;
     */
    isScreenClear: boolean;
    /**
     * @generated from protobuf field: string activeFileImage = 2;
     */
    activeFileImage: string;
    /**
     * @generated from protobuf field: UpdateConfiguration updateConfiguration = 3;
     */
    updateConfiguration?: UpdateConfiguration;
}
/**
 * @generated from protobuf message UpdateResponse
 */
export interface UpdateResponse {
    /**
     * @generated from protobuf field: uint32 boardUptimeInMs = 1;
     */
    boardUptimeInMs: number;
}
/**
 * @generated from protobuf message MyProjectResponse
 */
export interface MyProjectResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "invalidCommandResponse";
        /**
         * @generated from protobuf field: InvalidCommandResponse invalidCommandResponse = 1;
         */
        invalidCommandResponse: InvalidCommandResponse;
    } | {
        oneofKind: "hatDetailsResponse";
        /**
         * @generated from protobuf field: HatDetailsResponse hatDetailsResponse = 2;
         */
        hatDetailsResponse: HatDetailsResponse;
    } | {
        oneofKind: "updateResponse";
        /**
         * @generated from protobuf field: UpdateResponse updateResponse = 3;
         */
        updateResponse: UpdateResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum UpdateType
 */
export enum UpdateType {
    /**
     * @generated from protobuf enum value: UpdateType_NotSet = 0;
     */
    UpdateType_NotSet = 0,
    /**
     * @generated from protobuf enum value: UpdateType_None = 1;
     */
    UpdateType_None = 1,
    /**
     * @generated from protobuf enum value: UpdateType_Interval = 2;
     */
    UpdateType_Interval = 2
}
/**
 * @generated from protobuf enum NoArgCommands
 */
export enum NoArgCommands {
    /**
     * @generated from protobuf enum value: Nac_NotSet = 0;
     */
    Nac_NotSet = 0,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToWhite = 1;
     */
    Nac_ClearScreenToWhite = 1,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToBlack = 2;
     */
    Nac_ClearScreenToBlack = 2,
    /**
     * @generated from protobuf enum value: Nac_GetHatDetails = 3;
     */
    Nac_GetHatDetails = 3,
    /**
     * @generated from protobuf enum value: Nac_RestartDevice = 4;
     */
    Nac_RestartDevice = 4
}
// @generated message type with reflection information, may provide speed optimized methods
class UpdateConfiguration$Type extends MessageType<UpdateConfiguration> {
    constructor() {
        super("UpdateConfiguration", [
            { no: 1, name: "updateType", kind: "enum", T: () => ["UpdateType", UpdateType] },
            { no: 2, name: "updateIntervalInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateConfiguration>): UpdateConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateType = 0;
        message.updateIntervalInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateConfiguration): UpdateConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateType updateType */ 1:
                    message.updateType = reader.int32();
                    break;
                case /* uint32 updateIntervalInMs */ 2:
                    message.updateIntervalInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateType updateType = 1; */
        if (message.updateType !== 0)
            writer.tag(1, WireType.Varint).int32(message.updateType);
        /* uint32 updateIntervalInMs = 2; */
        if (message.updateIntervalInMs !== 0)
            writer.tag(2, WireType.Varint).uint32(message.updateIntervalInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateConfiguration
 */
export const UpdateConfiguration = new UpdateConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetUpdateConfiguration$Type extends MessageType<SetUpdateConfiguration> {
    constructor() {
        super("SetUpdateConfiguration", [
            { no: 1, name: "updateConfiguration", kind: "message", T: () => UpdateConfiguration },
            { no: 2, name: "saveConfiguration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetUpdateConfiguration>): SetUpdateConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.saveConfiguration = false;
        if (value !== undefined)
            reflectionMergePartial<SetUpdateConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetUpdateConfiguration): SetUpdateConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateConfiguration updateConfiguration */ 1:
                    message.updateConfiguration = UpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.updateConfiguration);
                    break;
                case /* bool saveConfiguration */ 2:
                    message.saveConfiguration = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetUpdateConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateConfiguration updateConfiguration = 1; */
        if (message.updateConfiguration)
            UpdateConfiguration.internalBinaryWrite(message.updateConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool saveConfiguration = 2; */
        if (message.saveConfiguration !== false)
            writer.tag(2, WireType.Varint).bool(message.saveConfiguration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetUpdateConfiguration
 */
export const SetUpdateConfiguration = new SetUpdateConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectCommand$Type extends MessageType<MyProjectCommand> {
    constructor() {
        super("MyProjectCommand", [
            { no: 1, name: "noArgCommand", kind: "enum", oneof: "command", T: () => ["NoArgCommands", NoArgCommands] },
            { no: 2, name: "showFileImage", kind: "scalar", oneof: "command", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "setUpdateConfiguration", kind: "message", oneof: "command", T: () => SetUpdateConfiguration }
        ]);
    }
    create(value?: PartialMessage<MyProjectCommand>): MyProjectCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectCommand): MyProjectCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NoArgCommands noArgCommand */ 1:
                    message.command = {
                        oneofKind: "noArgCommand",
                        noArgCommand: reader.int32()
                    };
                    break;
                case /* string showFileImage */ 2:
                    message.command = {
                        oneofKind: "showFileImage",
                        showFileImage: reader.string()
                    };
                    break;
                case /* SetUpdateConfiguration setUpdateConfiguration */ 3:
                    message.command = {
                        oneofKind: "setUpdateConfiguration",
                        setUpdateConfiguration: SetUpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setUpdateConfiguration)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NoArgCommands noArgCommand = 1; */
        if (message.command.oneofKind === "noArgCommand")
            writer.tag(1, WireType.Varint).int32(message.command.noArgCommand);
        /* string showFileImage = 2; */
        if (message.command.oneofKind === "showFileImage")
            writer.tag(2, WireType.LengthDelimited).string(message.command.showFileImage);
        /* SetUpdateConfiguration setUpdateConfiguration = 3; */
        if (message.command.oneofKind === "setUpdateConfiguration")
            SetUpdateConfiguration.internalBinaryWrite(message.command.setUpdateConfiguration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectCommand
 */
export const MyProjectCommand = new MyProjectCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvalidCommandResponse$Type extends MessageType<InvalidCommandResponse> {
    constructor() {
        super("InvalidCommandResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InvalidCommandResponse>): InvalidCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<InvalidCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvalidCommandResponse): InvalidCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvalidCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InvalidCommandResponse
 */
export const InvalidCommandResponse = new InvalidCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HatDetailsResponse$Type extends MessageType<HatDetailsResponse> {
    constructor() {
        super("HatDetailsResponse", [
            { no: 1, name: "isScreenClear", kind: "scalar", T: 8 /*ScalarType.BOOL*/ },
            { no: 2, name: "activeFileImage", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "updateConfiguration", kind: "message", T: () => UpdateConfiguration }
        ]);
    }
    create(value?: PartialMessage<HatDetailsResponse>): HatDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.isScreenClear = false;
        message.activeFileImage = "";
        if (value !== undefined)
            reflectionMergePartial<HatDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HatDetailsResponse): HatDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool isScreenClear */ 1:
                    message.isScreenClear = reader.bool();
                    break;
                case /* string activeFileImage */ 2:
                    message.activeFileImage = reader.string();
                    break;
                case /* UpdateConfiguration updateConfiguration */ 3:
                    message.updateConfiguration = UpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.updateConfiguration);
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HatDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool isScreenClear = 1; */
        if (message.isScreenClear !== false)
            writer.tag(1, WireType.Varint).bool(message.isScreenClear);
        /* string activeFileImage = 2; */
        if (message.activeFileImage !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.activeFileImage);
        /* UpdateConfiguration updateConfiguration = 3; */
        if (message.updateConfiguration)
            UpdateConfiguration.internalBinaryWrite(message.updateConfiguration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HatDetailsResponse
 */
export const HatDetailsResponse = new HatDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
    constructor() {
        super("UpdateResponse", [
            { no: 1, name: "boardUptimeInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boardUptimeInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateResponse): UpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 boardUptimeInMs */ 1:
                    message.boardUptimeInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 boardUptimeInMs = 1; */
        if (message.boardUptimeInMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.boardUptimeInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectResponse$Type extends MessageType<MyProjectResponse> {
    constructor() {
        super("MyProjectResponse", [
            { no: 1, name: "invalidCommandResponse", kind: "message", oneof: "response", T: () => InvalidCommandResponse },
            { no: 2, name: "hatDetailsResponse", kind: "message", oneof: "response", T: () => HatDetailsResponse },
            { no: 3, name: "updateResponse", kind: "message", oneof: "response", T: () => UpdateResponse }
        ]);
    }
    create(value?: PartialMessage<MyProjectResponse>): MyProjectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectResponse): MyProjectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* InvalidCommandResponse invalidCommandResponse */ 1:
                    message.response = {
                        oneofKind: "invalidCommandResponse",
                        invalidCommandResponse: InvalidCommandResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).invalidCommandResponse)
                    };
                    break;
                case /* HatDetailsResponse hatDetailsResponse */ 2:
                    message.response = {
                        oneofKind: "hatDetailsResponse",
                        hatDetailsResponse: HatDetailsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).hatDetailsResponse)
                    };
                    break;
                case /* UpdateResponse updateResponse */ 3:
                    message.response = {
                        oneofKind: "updateResponse",
                        updateResponse: UpdateResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).updateResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* InvalidCommandResponse invalidCommandResponse = 1; */
        if (message.response.oneofKind === "invalidCommandResponse")
            InvalidCommandResponse.internalBinaryWrite(message.response.invalidCommandResponse, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* HatDetailsResponse hatDetailsResponse = 2; */
        if (message.response.oneofKind === "hatDetailsResponse")
            HatDetailsResponse.internalBinaryWrite(message.response.hatDetailsResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* UpdateResponse updateResponse = 3; */
        if (message.response.oneofKind === "updateResponse")
            UpdateResponse.internalBinaryWrite(message.response.updateResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectResponse
 */
export const MyProjectResponse = new MyProjectResponse$Type();
