// @generated by protobuf-ts 2.9.3 with parameter use_proto_field_name,generate_dependencies
// @generated from protobuf file "my-project-messages.proto" (syntax proto3)
// tslint:disable
import type { BinaryWriteOptions } from "@protobuf-ts/runtime";
import type { IBinaryWriter } from "@protobuf-ts/runtime";
import { WireType } from "@protobuf-ts/runtime";
import type { BinaryReadOptions } from "@protobuf-ts/runtime";
import type { IBinaryReader } from "@protobuf-ts/runtime";
import { UnknownFieldHandler } from "@protobuf-ts/runtime";
import type { PartialMessage } from "@protobuf-ts/runtime";
import { reflectionMergePartial } from "@protobuf-ts/runtime";
import { MessageType } from "@protobuf-ts/runtime";
/**
 * @generated from protobuf message UpdateConfiguration
 */
export interface UpdateConfiguration {
    /**
     * @generated from protobuf field: UpdateType updateType = 1;
     */
    updateType: UpdateType;
    /**
     * @generated from protobuf field: uint32 updateIntervalInMs = 2;
     */
    updateIntervalInMs: number;
}
/**
 * @generated from protobuf message SetUpdateConfiguration
 */
export interface SetUpdateConfiguration {
    /**
     * @generated from protobuf field: UpdateConfiguration updateConfiguration = 1;
     */
    updateConfiguration?: UpdateConfiguration;
    /**
     * @generated from protobuf field: bool saveConfiguration = 2;
     */
    saveConfiguration: boolean;
}
/**
 * @generated from protobuf message HatConfiguration
 */
export interface HatConfiguration {
    /**
     * @generated from protobuf field: bool rotateImage = 1;
     */
    rotateImage: boolean;
}
/**
 * @generated from protobuf message SetHatConfiguration
 */
export interface SetHatConfiguration {
    /**
     * @generated from protobuf field: HatConfiguration hatConfiguration = 1;
     */
    hatConfiguration?: HatConfiguration;
    /**
     * @generated from protobuf field: bool saveConfiguration = 2;
     */
    saveConfiguration: boolean;
}
/**
 * @generated from protobuf message MyProjectCommand
 */
export interface MyProjectCommand {
    /**
     * @generated from protobuf oneof: command
     */
    command: {
        oneofKind: "noArgCommand";
        /**
         * @generated from protobuf field: NoArgCommands noArgCommand = 1;
         */
        noArgCommand: NoArgCommands;
    } | {
        oneofKind: "showFileImage";
        /**
         * @generated from protobuf field: string showFileImage = 2;
         */
        showFileImage: string;
    } | {
        oneofKind: "setUpdateConfiguration";
        /**
         * @generated from protobuf field: SetUpdateConfiguration setUpdateConfiguration = 3;
         */
        setUpdateConfiguration: SetUpdateConfiguration;
    } | {
        oneofKind: "setHatConfiguration";
        /**
         * @generated from protobuf field: SetHatConfiguration setHatConfiguration = 4;
         */
        setHatConfiguration: SetHatConfiguration;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf message InvalidCommandResponse
 */
export interface InvalidCommandResponse {
    /**
     * @generated from protobuf field: string message = 1;
     */
    message: string;
}
/**
 * @generated from protobuf message HatDetailsResponse
 */
export interface HatDetailsResponse {
    /**
     * @generated from protobuf field: UpdateConfiguration updateConfiguration = 1;
     */
    updateConfiguration?: UpdateConfiguration;
    /**
     * @generated from protobuf field: HatConfiguration hatConfiguration = 2;
     */
    hatConfiguration?: HatConfiguration;
    /**
     * @generated from protobuf field: string activeImageFile = 3;
     */
    activeImageFile: string;
    /**
     * @generated from protobuf field: string activeImageLabel = 4;
     */
    activeImageLabel: string;
}
/**
 * @generated from protobuf message FirmwareDetailsResponse
 */
export interface FirmwareDetailsResponse {
    /**
     * @generated from protobuf field: string version = 1;
     */
    version: string;
    /**
     * @generated from protobuf field: string buildTime = 2;
     */
    buildTime: string;
}
/**
 * @generated from protobuf message UpdateResponse
 */
export interface UpdateResponse {
    /**
     * @generated from protobuf field: uint32 boardUptimeInMs = 1;
     */
    boardUptimeInMs: number;
}
/**
 * @generated from protobuf message MyProjectResponse
 */
export interface MyProjectResponse {
    /**
     * @generated from protobuf oneof: response
     */
    response: {
        oneofKind: "invalidCommandResponse";
        /**
         * @generated from protobuf field: InvalidCommandResponse invalidCommandResponse = 1;
         */
        invalidCommandResponse: InvalidCommandResponse;
    } | {
        oneofKind: "hatDetailsResponse";
        /**
         * @generated from protobuf field: HatDetailsResponse hatDetailsResponse = 2;
         */
        hatDetailsResponse: HatDetailsResponse;
    } | {
        oneofKind: "firmwareDetailsResponse";
        /**
         * @generated from protobuf field: FirmwareDetailsResponse firmwareDetailsResponse = 3;
         */
        firmwareDetailsResponse: FirmwareDetailsResponse;
    } | {
        oneofKind: "updateResponse";
        /**
         * @generated from protobuf field: UpdateResponse updateResponse = 4;
         */
        updateResponse: UpdateResponse;
    } | {
        oneofKind: undefined;
    };
}
/**
 * @generated from protobuf enum UpdateType
 */
export enum UpdateType {
    /**
     * @generated from protobuf enum value: UpdateType_NotSet = 0;
     */
    UpdateType_NotSet = 0,
    /**
     * @generated from protobuf enum value: UpdateType_None = 1;
     */
    UpdateType_None = 1,
    /**
     * @generated from protobuf enum value: UpdateType_Interval = 2;
     */
    UpdateType_Interval = 2
}
/**
 * @generated from protobuf enum NoArgCommands
 */
export enum NoArgCommands {
    /**
     * @generated from protobuf enum value: Nac_NotSet = 0;
     */
    Nac_NotSet = 0,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToWhite = 1;
     */
    Nac_ClearScreenToWhite = 1,
    /**
     * @generated from protobuf enum value: Nac_ClearScreenToBlack = 2;
     */
    Nac_ClearScreenToBlack = 2,
    /**
     * @generated from protobuf enum value: Nac_GetHatDetails = 3;
     */
    Nac_GetHatDetails = 3,
    /**
     * @generated from protobuf enum value: Nac_GetFirmwareDetails = 4;
     */
    Nac_GetFirmwareDetails = 4,
    /**
     * @generated from protobuf enum value: Nac_RestartDevice = 5;
     */
    Nac_RestartDevice = 5
}
// @generated message type with reflection information, may provide speed optimized methods
class UpdateConfiguration$Type extends MessageType<UpdateConfiguration> {
    constructor() {
        super("UpdateConfiguration", [
            { no: 1, name: "updateType", kind: "enum", T: () => ["UpdateType", UpdateType] },
            { no: 2, name: "updateIntervalInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateConfiguration>): UpdateConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.updateType = 0;
        message.updateIntervalInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateConfiguration): UpdateConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateType updateType */ 1:
                    message.updateType = reader.int32();
                    break;
                case /* uint32 updateIntervalInMs */ 2:
                    message.updateIntervalInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateType updateType = 1; */
        if (message.updateType !== 0)
            writer.tag(1, WireType.Varint).int32(message.updateType);
        /* uint32 updateIntervalInMs = 2; */
        if (message.updateIntervalInMs !== 0)
            writer.tag(2, WireType.Varint).uint32(message.updateIntervalInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateConfiguration
 */
export const UpdateConfiguration = new UpdateConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetUpdateConfiguration$Type extends MessageType<SetUpdateConfiguration> {
    constructor() {
        super("SetUpdateConfiguration", [
            { no: 1, name: "updateConfiguration", kind: "message", T: () => UpdateConfiguration },
            { no: 2, name: "saveConfiguration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetUpdateConfiguration>): SetUpdateConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.saveConfiguration = false;
        if (value !== undefined)
            reflectionMergePartial<SetUpdateConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetUpdateConfiguration): SetUpdateConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateConfiguration updateConfiguration */ 1:
                    message.updateConfiguration = UpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.updateConfiguration);
                    break;
                case /* bool saveConfiguration */ 2:
                    message.saveConfiguration = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetUpdateConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateConfiguration updateConfiguration = 1; */
        if (message.updateConfiguration)
            UpdateConfiguration.internalBinaryWrite(message.updateConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool saveConfiguration = 2; */
        if (message.saveConfiguration !== false)
            writer.tag(2, WireType.Varint).bool(message.saveConfiguration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetUpdateConfiguration
 */
export const SetUpdateConfiguration = new SetUpdateConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HatConfiguration$Type extends MessageType<HatConfiguration> {
    constructor() {
        super("HatConfiguration", [
            { no: 1, name: "rotateImage", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<HatConfiguration>): HatConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.rotateImage = false;
        if (value !== undefined)
            reflectionMergePartial<HatConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HatConfiguration): HatConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* bool rotateImage */ 1:
                    message.rotateImage = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HatConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* bool rotateImage = 1; */
        if (message.rotateImage !== false)
            writer.tag(1, WireType.Varint).bool(message.rotateImage);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HatConfiguration
 */
export const HatConfiguration = new HatConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class SetHatConfiguration$Type extends MessageType<SetHatConfiguration> {
    constructor() {
        super("SetHatConfiguration", [
            { no: 1, name: "hatConfiguration", kind: "message", T: () => HatConfiguration },
            { no: 2, name: "saveConfiguration", kind: "scalar", T: 8 /*ScalarType.BOOL*/ }
        ]);
    }
    create(value?: PartialMessage<SetHatConfiguration>): SetHatConfiguration {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.saveConfiguration = false;
        if (value !== undefined)
            reflectionMergePartial<SetHatConfiguration>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: SetHatConfiguration): SetHatConfiguration {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* HatConfiguration hatConfiguration */ 1:
                    message.hatConfiguration = HatConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.hatConfiguration);
                    break;
                case /* bool saveConfiguration */ 2:
                    message.saveConfiguration = reader.bool();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: SetHatConfiguration, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* HatConfiguration hatConfiguration = 1; */
        if (message.hatConfiguration)
            HatConfiguration.internalBinaryWrite(message.hatConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* bool saveConfiguration = 2; */
        if (message.saveConfiguration !== false)
            writer.tag(2, WireType.Varint).bool(message.saveConfiguration);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message SetHatConfiguration
 */
export const SetHatConfiguration = new SetHatConfiguration$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectCommand$Type extends MessageType<MyProjectCommand> {
    constructor() {
        super("MyProjectCommand", [
            { no: 1, name: "noArgCommand", kind: "enum", oneof: "command", T: () => ["NoArgCommands", NoArgCommands] },
            { no: 2, name: "showFileImage", kind: "scalar", oneof: "command", T: 9 /*ScalarType.STRING*/ },
            { no: 3, name: "setUpdateConfiguration", kind: "message", oneof: "command", T: () => SetUpdateConfiguration },
            { no: 4, name: "setHatConfiguration", kind: "message", oneof: "command", T: () => SetHatConfiguration }
        ]);
    }
    create(value?: PartialMessage<MyProjectCommand>): MyProjectCommand {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.command = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectCommand>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectCommand): MyProjectCommand {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* NoArgCommands noArgCommand */ 1:
                    message.command = {
                        oneofKind: "noArgCommand",
                        noArgCommand: reader.int32()
                    };
                    break;
                case /* string showFileImage */ 2:
                    message.command = {
                        oneofKind: "showFileImage",
                        showFileImage: reader.string()
                    };
                    break;
                case /* SetUpdateConfiguration setUpdateConfiguration */ 3:
                    message.command = {
                        oneofKind: "setUpdateConfiguration",
                        setUpdateConfiguration: SetUpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setUpdateConfiguration)
                    };
                    break;
                case /* SetHatConfiguration setHatConfiguration */ 4:
                    message.command = {
                        oneofKind: "setHatConfiguration",
                        setHatConfiguration: SetHatConfiguration.internalBinaryRead(reader, reader.uint32(), options, (message.command as any).setHatConfiguration)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectCommand, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* NoArgCommands noArgCommand = 1; */
        if (message.command.oneofKind === "noArgCommand")
            writer.tag(1, WireType.Varint).int32(message.command.noArgCommand);
        /* string showFileImage = 2; */
        if (message.command.oneofKind === "showFileImage")
            writer.tag(2, WireType.LengthDelimited).string(message.command.showFileImage);
        /* SetUpdateConfiguration setUpdateConfiguration = 3; */
        if (message.command.oneofKind === "setUpdateConfiguration")
            SetUpdateConfiguration.internalBinaryWrite(message.command.setUpdateConfiguration, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* SetHatConfiguration setHatConfiguration = 4; */
        if (message.command.oneofKind === "setHatConfiguration")
            SetHatConfiguration.internalBinaryWrite(message.command.setHatConfiguration, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectCommand
 */
export const MyProjectCommand = new MyProjectCommand$Type();
// @generated message type with reflection information, may provide speed optimized methods
class InvalidCommandResponse$Type extends MessageType<InvalidCommandResponse> {
    constructor() {
        super("InvalidCommandResponse", [
            { no: 1, name: "message", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<InvalidCommandResponse>): InvalidCommandResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.message = "";
        if (value !== undefined)
            reflectionMergePartial<InvalidCommandResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: InvalidCommandResponse): InvalidCommandResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string message */ 1:
                    message.message = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: InvalidCommandResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string message = 1; */
        if (message.message !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.message);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message InvalidCommandResponse
 */
export const InvalidCommandResponse = new InvalidCommandResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class HatDetailsResponse$Type extends MessageType<HatDetailsResponse> {
    constructor() {
        super("HatDetailsResponse", [
            { no: 1, name: "updateConfiguration", kind: "message", T: () => UpdateConfiguration },
            { no: 2, name: "hatConfiguration", kind: "message", T: () => HatConfiguration },
            { no: 3, name: "activeImageFile", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 4, name: "activeImageLabel", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<HatDetailsResponse>): HatDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.activeImageFile = "";
        message.activeImageLabel = "";
        if (value !== undefined)
            reflectionMergePartial<HatDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: HatDetailsResponse): HatDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* UpdateConfiguration updateConfiguration */ 1:
                    message.updateConfiguration = UpdateConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.updateConfiguration);
                    break;
                case /* HatConfiguration hatConfiguration */ 2:
                    message.hatConfiguration = HatConfiguration.internalBinaryRead(reader, reader.uint32(), options, message.hatConfiguration);
                    break;
                case /* string activeImageFile */ 3:
                    message.activeImageFile = reader.string();
                    break;
                case /* string activeImageLabel */ 4:
                    message.activeImageLabel = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: HatDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* UpdateConfiguration updateConfiguration = 1; */
        if (message.updateConfiguration)
            UpdateConfiguration.internalBinaryWrite(message.updateConfiguration, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* HatConfiguration hatConfiguration = 2; */
        if (message.hatConfiguration)
            HatConfiguration.internalBinaryWrite(message.hatConfiguration, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* string activeImageFile = 3; */
        if (message.activeImageFile !== "")
            writer.tag(3, WireType.LengthDelimited).string(message.activeImageFile);
        /* string activeImageLabel = 4; */
        if (message.activeImageLabel !== "")
            writer.tag(4, WireType.LengthDelimited).string(message.activeImageLabel);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message HatDetailsResponse
 */
export const HatDetailsResponse = new HatDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class FirmwareDetailsResponse$Type extends MessageType<FirmwareDetailsResponse> {
    constructor() {
        super("FirmwareDetailsResponse", [
            { no: 1, name: "version", kind: "scalar", T: 9 /*ScalarType.STRING*/ },
            { no: 2, name: "buildTime", kind: "scalar", T: 9 /*ScalarType.STRING*/ }
        ]);
    }
    create(value?: PartialMessage<FirmwareDetailsResponse>): FirmwareDetailsResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.version = "";
        message.buildTime = "";
        if (value !== undefined)
            reflectionMergePartial<FirmwareDetailsResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: FirmwareDetailsResponse): FirmwareDetailsResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* string version */ 1:
                    message.version = reader.string();
                    break;
                case /* string buildTime */ 2:
                    message.buildTime = reader.string();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: FirmwareDetailsResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* string version = 1; */
        if (message.version !== "")
            writer.tag(1, WireType.LengthDelimited).string(message.version);
        /* string buildTime = 2; */
        if (message.buildTime !== "")
            writer.tag(2, WireType.LengthDelimited).string(message.buildTime);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message FirmwareDetailsResponse
 */
export const FirmwareDetailsResponse = new FirmwareDetailsResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class UpdateResponse$Type extends MessageType<UpdateResponse> {
    constructor() {
        super("UpdateResponse", [
            { no: 1, name: "boardUptimeInMs", kind: "scalar", T: 13 /*ScalarType.UINT32*/ }
        ]);
    }
    create(value?: PartialMessage<UpdateResponse>): UpdateResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.boardUptimeInMs = 0;
        if (value !== undefined)
            reflectionMergePartial<UpdateResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: UpdateResponse): UpdateResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* uint32 boardUptimeInMs */ 1:
                    message.boardUptimeInMs = reader.uint32();
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: UpdateResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* uint32 boardUptimeInMs = 1; */
        if (message.boardUptimeInMs !== 0)
            writer.tag(1, WireType.Varint).uint32(message.boardUptimeInMs);
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message UpdateResponse
 */
export const UpdateResponse = new UpdateResponse$Type();
// @generated message type with reflection information, may provide speed optimized methods
class MyProjectResponse$Type extends MessageType<MyProjectResponse> {
    constructor() {
        super("MyProjectResponse", [
            { no: 1, name: "invalidCommandResponse", kind: "message", oneof: "response", T: () => InvalidCommandResponse },
            { no: 2, name: "hatDetailsResponse", kind: "message", oneof: "response", T: () => HatDetailsResponse },
            { no: 3, name: "firmwareDetailsResponse", kind: "message", oneof: "response", T: () => FirmwareDetailsResponse },
            { no: 4, name: "updateResponse", kind: "message", oneof: "response", T: () => UpdateResponse }
        ]);
    }
    create(value?: PartialMessage<MyProjectResponse>): MyProjectResponse {
        const message = globalThis.Object.create((this.messagePrototype!));
        message.response = { oneofKind: undefined };
        if (value !== undefined)
            reflectionMergePartial<MyProjectResponse>(this, message, value);
        return message;
    }
    internalBinaryRead(reader: IBinaryReader, length: number, options: BinaryReadOptions, target?: MyProjectResponse): MyProjectResponse {
        let message = target ?? this.create(), end = reader.pos + length;
        while (reader.pos < end) {
            let [fieldNo, wireType] = reader.tag();
            switch (fieldNo) {
                case /* InvalidCommandResponse invalidCommandResponse */ 1:
                    message.response = {
                        oneofKind: "invalidCommandResponse",
                        invalidCommandResponse: InvalidCommandResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).invalidCommandResponse)
                    };
                    break;
                case /* HatDetailsResponse hatDetailsResponse */ 2:
                    message.response = {
                        oneofKind: "hatDetailsResponse",
                        hatDetailsResponse: HatDetailsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).hatDetailsResponse)
                    };
                    break;
                case /* FirmwareDetailsResponse firmwareDetailsResponse */ 3:
                    message.response = {
                        oneofKind: "firmwareDetailsResponse",
                        firmwareDetailsResponse: FirmwareDetailsResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).firmwareDetailsResponse)
                    };
                    break;
                case /* UpdateResponse updateResponse */ 4:
                    message.response = {
                        oneofKind: "updateResponse",
                        updateResponse: UpdateResponse.internalBinaryRead(reader, reader.uint32(), options, (message.response as any).updateResponse)
                    };
                    break;
                default:
                    let u = options.readUnknownField;
                    if (u === "throw")
                        throw new globalThis.Error(`Unknown field ${fieldNo} (wire type ${wireType}) for ${this.typeName}`);
                    let d = reader.skip(wireType);
                    if (u !== false)
                        (u === true ? UnknownFieldHandler.onRead : u)(this.typeName, message, fieldNo, wireType, d);
            }
        }
        return message;
    }
    internalBinaryWrite(message: MyProjectResponse, writer: IBinaryWriter, options: BinaryWriteOptions): IBinaryWriter {
        /* InvalidCommandResponse invalidCommandResponse = 1; */
        if (message.response.oneofKind === "invalidCommandResponse")
            InvalidCommandResponse.internalBinaryWrite(message.response.invalidCommandResponse, writer.tag(1, WireType.LengthDelimited).fork(), options).join();
        /* HatDetailsResponse hatDetailsResponse = 2; */
        if (message.response.oneofKind === "hatDetailsResponse")
            HatDetailsResponse.internalBinaryWrite(message.response.hatDetailsResponse, writer.tag(2, WireType.LengthDelimited).fork(), options).join();
        /* FirmwareDetailsResponse firmwareDetailsResponse = 3; */
        if (message.response.oneofKind === "firmwareDetailsResponse")
            FirmwareDetailsResponse.internalBinaryWrite(message.response.firmwareDetailsResponse, writer.tag(3, WireType.LengthDelimited).fork(), options).join();
        /* UpdateResponse updateResponse = 4; */
        if (message.response.oneofKind === "updateResponse")
            UpdateResponse.internalBinaryWrite(message.response.updateResponse, writer.tag(4, WireType.LengthDelimited).fork(), options).join();
        let u = options.writeUnknownFields;
        if (u !== false)
            (u == true ? UnknownFieldHandler.onWrite : u)(this.typeName, message, writer);
        return writer;
    }
}
/**
 * @generated MessageType for protobuf message MyProjectResponse
 */
export const MyProjectResponse = new MyProjectResponse$Type();
